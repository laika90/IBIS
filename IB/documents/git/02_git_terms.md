# 02 Git 基本用語集

みんなが（~~僕が~~）つまづく基本用語集を作ったよ！

</br>

## リポジトリ（Repositories）
リポジトリ，とは **「ファイルやディレクトリ（フォルダ）などの状態を記録する場所」** のことです。 ディレクトリのことではないです。データベース的なものでしょうか。  

あるディレクトリ（それこそこういうプロジェクトとかのディレクトリ）をGitで管理したいときに，`git init`とかタイプしたと思います。このディレクトリ（新規でも良い）をGitの管理下に置くよ（初期化），と言う意味ですね。

`git init`をすると，そのディレクトリ内部に`.git`というディレクトリができます。拡張子が`.`始まりなので，見ようと思わないと見えないですが，ちゃんとあります。ここに色々保存されているんですね（これは後述しますがローカルです）。こんな感じです。  

<img src=https://github.com/laika90/b2multicopter/blob/master/documents/git/images/02_01.png width="320px">  

</br>

このリポジトリには2種類あります。それが，
* リモートリポジトリ
* ローカルリポジトリ

の2つ。

### リモートリポジトリ
その名の通り，リモートにあるリポジトリです。複数人で管理するリポジトリで，ここからローカルの方にクローンしたりプルしたりします。

### ローカルリポジトリ
こちらもその名の通り，ローカルにあるリポジトリです。自分が利用するために，ローカル環境で用います。色々編集したファイルをローカルリポジトリに入れれば，そこからリモートリポジトリにアップロードできます。そうすると他の人はリモートリポジトリからプルすれば，自分が編集した内容を閲覧できるってことですね。

参考図。（[ここ](https://qiita.com/_ha1f/items/2dca1047c57d4f0bd465)からとってきました。自分で描こうとしたが画力がなかった。）  

<img src=https://github.com/laika90/b2multicopter/blob/master/documents/git/images/02_02.png width="320px">  

（こういう画像って公式にあっても良さそうだけど，公式には一切なかった。公式がこういう考え方は推奨してないってことなのかな...？）

</br>

<details><summary> 補足 〜作業ディレクトリとの違いがわからないあなたに〜</summary>

</br> 

リポジトリとはさっき述べたように， **「ファイルやディレクトリ（フォルダ）などの状態を記録する場所」** のことを指すので，コミットやステージングエリア，ブランチ等のGit特有のデータを持ちます。  

例えばですが，`hoge.py`が，ディレクトリ`pyworks`の中に入っているとしましょう。
```zsh
pyworks 
└── hoge.py
```
この`hoge.py`に変更を加えて，これをコミットしよう！と思い，以下のようにしました。
```zsh
$ git add hoge.py
$ git commit -m "[Modify] hoge.py"
```
このコミットの行き先が「リポジトリ」になります。

作業ディレクトリとはただの作業ファイルの入れ物です。それ以上の役割をしませんし，それ以下の役割もしません。つまり， **ただの作業ディレクトリならば，Gitに関する情報というのは一切入っていません** 。  

しかし，Git支配下の作業ディレクトリで`$ git status`と叩いたら作業ファイルの情報なりがブワーっと出てきますよね。ただし，作業ディレクトリとは上で言ったようにただの作業ファイルの入れ物ですから，こういう情報は本来持ってません。ならその情報はどこから出てきたのでしょう？そのデータの住所が「リポジトリ」です。  

ではこの「リポジトリ」というものは実体（ディレクトリのような）を持たないのかと言われるとそうではありません。「ローカルリポジトリ」というくらいですしおすし。気になるローカルリポジトリの正体は，さっきちらっと出てきた， **`.git`ディレクトリ** です。  

は？？？ディレクトリじゃん。。。と思った画面のあなた，正解です。さんざんディレクトリとは違うと言っておきながらディレクトリでしたすみません。とはいえ， **作業ディレクトリ（ワーキングツリー）とは別物** です。だって隠しファイルの中で作業なんて普通しないでしょ？？  

そこで，私の`b2multicopter`ディレクトリを実際に見てみましょう。  
```zsh
b2multicopter   
├── README.md   
└── document  
    └── git
        ├── 01_about_git.md  
        └── 02_git_terms.md  
```
となっています。これが作業ディレクトリです。実際に作業する場所ですね。それでは隠しファイルを表示させると，，
```zsh
b2multicopter   
├── README.md   
├── document  
│   └── git
│       ├── 01_about_git.md  
│       └── 02_git_terms.md  
│
└── .git
    ├── logs
    ├── refs
    ├── objects
    ├── HEAD
    │
    ...
```
という構造になっています，この`.git`がリポジトリ，その中にある`logs`とか`refs`とかが実際にリポジトリが保持している情報になるわけですね。  

例えば，`b2multicopter/.git/logs/refs/heads/master`を見てみましょう。ここには今まで全ての（masterブランチにおける）コミット履歴が入っています。このファイルの一番上の行はこんな感じです。
```zsh
0000000000000000000000000000000000000000 8480bae0c650fca31e202e46f6043bdb3f47f31a laika90 <僕のメアド> 1665123152 +0900	commit (initial): first commit
```
これは一番最初のコミットを表しています。「コミットはその瞬間でのスナップショット」と言いましたが，この40桁のうじゃうじゃしたものはコミットの名前です（こんなうじゃうじゃさせてるのは暗号化のためです。セキュリティ大事）。つまり，一番最初のコミットの名前は`8480bae0c650fca31e202e46f6043bdb3f47f31a`というわけです。よろしくね！`8480bae0c650fca31e202e46f6043bdb3f47f31a`くん！！！  

今まで見てきたように，`.git`ディレクトリにはさまざまな情報，特にコミットの歴史が詰まっています。開発者様は，この歴史が詰まった場所をなんと呼ぼうかなーと考えた末にこれを「リポジトリ」と名付けたわけです，知らんけど。  

これで，「リポジトリ」は作業ディレクトリは異なるもので， **「ファイルやディレクトリ（フォルダ）などの状態を記録する場所」** である，ということの意味がなんとなく体感できたでしょうか？？  

まとめると  

* **「作業ディレクトリ」** は **「作業ファイルを管理する場所」**  
* **「リポジトリ」** は **「Git特有の情報を管理する場所」**   

ということです。ただ，ローカルリポジトリが作業ディレクトリの中にあるからあれ？って思うだけで。

</details>

</br>

## ワーキングツリー（Working Tree） 

何かローカルリポジトリと似てね？と思ったそこのあなた。全然違います（）。思ってしまったあなたは，上の補足を読んでみてください。  

ローカルリポジトリは **「ファイルやディレクトリ（フォルダ）などの状態をローカルで記録する場所」** のことでした。なのでファイルの編集などはできません（`.git`下を弄ればできるかもしれんけど。知らんけど。）。  

なので， **「ファイルの編集を実際に行う場所」** が必要になりますが，これがワーキングツリー（ワーキングディレクトリ）にあたります。今あなたがいるディレクトリや触っているファイル群のことですね。  

例えばこれを書いているときは，
```zsh
b2multicopter   
├── README.md   
└── document  
    └── git
        ├── 01_about_git.md  
        └── 02_git_terms.md  
```
というディレクトリ構造になっていますが，`b2multicopter`とか`document`とか`git`といったディレクトリは全てワーキングツリーにあたります。なぜなら，その場所でファイルを実際に編集するからですね。木みたいになっているのでtreeというんですね。  

Gitの公式ドキュメントには，
>Think of the working directory as a **sandbox**, where you can try changes out before committing them to your staging area (index) and then to history.   

と記載されています。変更を加える前に修正できるサンドボックスのような場所と説明されています。

</br>

## ステージングエリア（Staging Area）

ローカルリポジトリとワーキングツリーは勝手に同期されているわけではないので，ワーキングツリーで加えた変更はローカルリポジトリには勝手に反映されず，反映を記録するために色々ポチポチしないといけません。  

さらにさらに，実はワーキングツリーから直接はローカルリポジトリに変更を保存できず，変更を保存するためには，ワーキングツリーとローカルリポジトリの間にある「ステージングエリア」（インデックス）に登録しなければなりません。  

図で示すとこんな感じです。（公式ドキュメントから）  

<img src=https://github.com/laika90/b2multicopter/blob/master/documents/git/images/02_03.png width="600px">  

なので，ワーキングツリーに加えた変更をローカルリポジトリに記録したいときは，  

ワーキングツリー → ステージングエリア → ローカルリポジトリ

という手順を踏むわけですね。  

このときの，「ワーキングツリー → ステージングエリア」の作業を`git add`で， 「ステージングエリア → ローカルリポジトリ」の作業を`git commit`でするわけです。（詳細は後述します。）  

</br>

## git status

ワーキングツリー内部の各ファイルには， 

* **追跡されているもの(tracked)**
* **追跡されていないもの(untracked)** 

の2通りが存在します。  

「追跡されているファイル」とは直近のスナップショットに存在したファイルのことを指し（※1），追跡されているファイルの状態には，

* **変更されていない(unmodified)**
* **変更されている(modified)**
* **ステージされている(staged)**

の3つの状態があります。

「追跡されていないファイル」はこれらのどれでもないです。ファイルは，これらの状態を行き来することになります。

<img src=https://github.com/laika90/b2multicopter/blob/master/documents/git/images/02_04.png width="600px">  

（公式ドキュメントから）  

この **ファイルの状態を確認** するのが`git status`です。  
これを打ち込めば，今現在がファイルがどのような状態になっているかが分かるわけです。

</br>

<details><summary>具体例（折りたたみ）</summary>

</br>

### EX1

例えば試しにこれを打ってみれば，
```zsh
$ git status

On branch master
Your branch is up to date with 'origin/master'.

nothing to commit, working tree clean
```

という返事が返ってきます。`nothing to commit, working tree clean`とか言っているので， **「追跡されているファイルの中でに変更されているものがないよ！しかも未追跡のファイルもないよ！」** と言っているわけです。 

### EX2

他にも，このファイル（02_git_terms.md）を修正したら（modified）,
```zsh
$ git status

On branch master
Your branch is up to date with 'origin/master'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   02_git_terms.md

no changes added to commit (use "git add" and/or "git commit -a")
```

という返事がきます。`Changes not staged for commit`のところに，`modified:   02_git_terms.md`という項目がありますね。これは， **「（コミットされるために）`02_git_terms.md`の変更がステージされてないよ！（つまりステージング・エリアに登録する必要があるよ！）」** ということを叫んでいるわけです。  

### EX3

更に更に，例えば新しく`03_hoge.md`というファイルを作ると，このファイルはまだ未追跡なので，untrackedなファイルとなります。  

そこで`git status`を打ち込んでみると，  
```zsh
$ git status

On branch master
Your branch is up to date with 'origin/master'.

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        03_hoge.md

nothing added to commit but untracked files present (use "git add" to track)
```

と返ってくるので，`Untracked files`に`03_hoge.md`を見れば， **「未追跡のファイル`03_hoge.md`があるよ！」** と教えてくれるわけです。  

う〜ん便利ですね。

</details>

</br>

<details><summary>簡略化（折りたたみ）</summary>

</br>

実は，`git status`はオプションをつけることで簡略表示ができます。あまりにもファイル数が多かったりすると冗長になって本当に見たいところが見にくくなってしまうからですね。~~まぁそんな状況僕にはないんですけど~~  

気になる使い方ですが，  

```zsh
$ git status -s
$ git status --short
```
のどちらかでできます。例えばこんな感じです。  

```zsh
$ git status -s

 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt
```
左側の大文字のところは，ファイル状態を表していて，一文字目が **「ステージされたファイルの状態」** を，二文字目が **「ファイルが変更されたか」** を表しています。  

それぞれの文字の内容は，下の通りです。  

| 文字 | 意味 |  
| ---- | ---- |  
| A | ステージングエリアに追加されたファイル |  
| M | 変更されたファイル |  
| ?? | 未追跡のファイル |  

なので，今回はこんな感じになります。  

| ファイル名 | 意味 |  
| ---- | ---- |  
| README | 変更したが，未ステージ |  
| Rakefile | 変更されステージ後，また変更 |  
| lib/git.rb | ステージングエリアに追加 |  
| lib/simplegit.rb | 変更され，ステージ済 |  
| LICENSE.txt | 未追跡 |  

`lib/git.rb`については，新規作成後，追跡を開始したものです。  

`Rakefile`は分かりにくいかもしれませんが，先ほどの`03_hoge.md`のように，旧版と新版が共存している状態を想像してみてください。変更の内容にも，ステージされたもの，そうでないものの2通りがあるということです。

</details>

</br>

<details><summary>※1（折りたたみ）</summary><div>  

</br>

ここの表現がイマイチわかりにくかったかもしれませんが，Gitにおいてはこのような表現を使います。  

Gitは他のVCS（Version Control System：バージョン管理システム）とは異なり，データを **「基本バージョンからの変更，差分」としてではなく，「一連のスナップショット」として** 考え，格納します。

他のVCS（公式ドキュメントより）  

<img src=https://github.com/laika90/b2multicopter/blob/master/documents/git/images/02_05.png width="600px">  

</br>  

Git（公式ドキュメントより）  

<img src=https://github.com/laika90/b2multicopter/blob/master/documents/git/images/02_06.png width="600px">  

</br>  

このようにGitはデータをミニファイルシステムのスナップショットのように考えます。Gitで全てのコミットをするとき，全てのファイルの状態のスナップショットを撮って，そのスナップショットへのリンクを格納するわけです。ファイルに変更がないなら，Gitはファイルの再格納をせず，すでに格納してある以前と同一のファイルへのリンクを格納します。これが効率化につながっているわけですね。  

なので，「直近のスナップショットに存在したファイル」というのは，「直近のコミットで存在したファイル」ということなわけですね。

</div>
</details>

</br>

## git add

`git add`には様々な意味があるので，できることも多々あります。主に使うのは以下のときです。

* 新しいファイルの追跡
* 変更したファイルのステージング
* 衝突発生時の解決済みマーキング

公式ドキュメントでは，

>「指定したファイルをプロジェクトに追加(add)するコマンド」，というよりは， **「指定した内容を次のコミットに追加(add)するコマンド」** ，と捉えるほうがわかりやすいかもしれません。  

と書いてありますが，おっしゃる通りです。取り敢えず公式に従っておきましょう。  

使い方は
```zsh
$ git add {ファイル名1} {ファイル名2} ...
```
で，{ファイル名}を追跡なり，ステージングエリアへ追加なりします。  

<img src=https://github.com/laika90/b2multicopter/blob/master/documents/git/images/02_04.png width="600px">  

</br>

この図で言うところの **「Add the file」と「Stage the file」** に相当します。  

一度に全てのファイルを`add`したい場合は，オプションをつけて，
```zsh
git add --a
```
とすると，`add`対象の全てのファイルが次のコミットの対象となります。allのaですね。  

</br>

<details><summary>具体例（折りたたみ）</summary>

</br>

### EX

先と同じように，`03_hoge.md`というファイルを作成したとしましょう。すると，さっき見たように，  
```zsh
$ git status

On branch master
Your branch is up to date with 'origin/master'.

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        03_hoge.md

nothing added to commit but untracked files present (use "git add" to track)
```  

となりますね。未追跡(untracked)なファイルです。これを追跡したいので，
```zsh
git add 03_hoge.md
```
とすれば，追跡できます。試しに`git status`で見てみると，
```zsh
$ git status

On branch master
Your branch is up to date with 'origin/master'.

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        new file:   03_hoge.md
```  

と返ってきます。`Changes to be committed`に`new file:   03_hoge.md`とあるから， **「次のコミット対象となるファイルには，新しいファイル（03_hoge.md）があるよ！」** と教えてくれるわけです。  

更にこの`03_hoge.md`というファイルをに変更を加えると，ファイルの状態は，「変更されている(modified)状態」となりますね。確かに，
```zsh
$ git status

On branch master
Your branch is up to date with 'origin/master'.

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        new file:   03_hoge.md

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   03_hoge.md
```  

となって，`Changes not staged for commit`に`modified:   03_hoge.md`として現れるわけです。でもあれ，ちょっと待ってください。`03_hoge.md` が、ステージされているほうとステージされていないほうの **両方** に登場しています。こんなことってありえるんでしょうか？（公式ドキュメント風）  

つまり，`git add`とは， **「git add コマンドを実行した時点の状態のファイル」をステージする** ということなんですね。なので，2つ現れている`03_hoge.md`は変更前と変更後ということです。別物です別物。

なのでここで`git commit`してしまうと，旧版の`03_hoge.md`のみがコミットされてしまうだけです。なので，新版の`03_hoge.md`をコミット対象にするために，もう一度`git add`をして，ステージングエリアに追加する必要があります。  
```
$ git add 03_hoge.md
$ git status

On branch master
Your branch is up to date with 'origin/master'.

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        new file:   03_hoge.md
```
となり，万事解決ですね〜。

</details>

</br>

## git commit

ステージング・エリアの準備ができたら，変更内容をコミットすることができます。  

さっきからコミットコミット言ってますが，コミットというのは，（公式曰く） **「ステージングエリアにあるファイルを取得し、永久不変に保持するスナップショットとしてGitディレクトリに格納すること」** です。要は，ステージングエリアにあるデータをローカルリポジトリに登録する作業，というイメージで良いと思います。    

</br>

<img src=https://github.com/laika90/b2multicopter/blob/master/documents/git/images/02_07.png width="600px">   

（公式ドキュメントより）  

コミット対象となるファイルは常に， **ステージングエリアにあるファイル** になります。なので，`git add`をしていないファイルに関しては何をどう足掻いてもコミットされず，変更履歴が保存されません（もちろん，ディレクトリ上にはあります）。注意しましょう。  

実際のコミットの仕方ですが，

```zsh
$ git commit -m "{メッセージ}"
```

となります。`{メッセージ}`の欄には変更内容など，そのコミットの小さな要約をつけておいてください。（「ああああ」とかでもいいんだけど，後々困ります。~~実体験~~）  

これでコミット完了です。コミットが完了すると，ローカルリポジトリにファイルの変更のスナップショットが保存されます。しかし，**コミットのみではリモートリポジトリには何の変更も保存されない** ことに注意。あくまでローカルの話です。  

このローカルからリモートへの移行が「プッシュ」です。これはまた後述します。 

</br>

<details><summary>もう少し詳細な話（折りたたみ）</summary>

</br>

さっきの`git commit -m`を見て，オプションじゃね？と思った方も多いはず。　　

実は（ハイフンついてるから丸見えですが）その通りでこの`-m`はオプションです。つまり，`git commit`だけでもいいですが，`-m`を付加することで追加の効果を発揮します（~~カードゲームかな？~~）。  

実際の利便性的にはこのオプションをつけた方が圧倒的に便利なので，これだけ覚えていれば日常生活に支障はきたさないんですが，折角なので本場の`git commit`についても見ていきます。  

普通に`git commit`のみ書くと，エディタが開いて（※2）このようになります。    
```zsh
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Changes to be committed:
#	new file:   README
#	modified:   CONTRIBUTING.md
#
~
~
~
".git/COMMIT_EDITMSG" 9L, 283C
```
ここのコメントアウト（#が文頭についてるところ）の部分が，コミットメッセージとして残ります。デフォルトのまま残しても良いし，ここを消して，好きなコミットメッセージを残しても良いわけです。このままエディタを終了させれば，コミットされます。  

つまり，オプション`-m`でやっているのは，デフォルトのコミットメッセージを全て消して`"{メッセージ}"`を追加しているだけですね。  

* ※2について。通常，`git commit`でコミットする際に開かれるエディタは，シェルの `$EDITOR`環境変数で設定されているエディタであり，通常 vim や emacs になります（この例では vim）。ただし`git config --global core.editor`で好きなエディタを設定することもできます。エディタについては書くかもしれないし書かないかもしれない。

</details>

</br>

<details><summary>ステージングエリアの省略（折りたたみ）</summary>

</br>

全くもって`git commit`のオプションを覚える必要はないんですが，便利なオプションがあれば覚えたら便利ですよね（~~進次郎？~~）。  

コミットの内容を思い通りに分けられるという点で，ステージングエリアはとても便利ですが，いちいちステージングエリアに追加してコミットして，というのは普段の作業ではめんどくさい場合が多いです。  

そこで`-a`オプションをつけると，ステージングエリアをすっ飛ばせます。（`git add --a`も一緒にやってくれるというわけです。）  

例えば，変更済，未ステージのファイルがあったとしてこれをコミットすれば，
```zsh
$ git commit -a -m '[Add] new benchmarks'

[master 83e38c7] added new benchmarks
 1 file changed, 5 insertions(+), 0 deletions(-)
```
といった具合です。  

ただし，意図しないコミットを誘発する可能性が十二分にあるので慎重に使いましょう。フリじゃないです。

</details>

</br>

<details><summary>具体例（折りたたみ）</summary>

</br>

### EX

示す必要もあんまりないとは思いますが，一応。  

```zsh
$ git status

On branch master
Your branch is up to date with 'origin/master'.

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        modified:   02_git_terms.md
```
のような，ファイルがステージングエリアにあるようなときに，コミットができます（何度も言いますが， **コミット対象となるのは，ステージングエリアにあるファイルのみ** です）。  

この場合は，`02_git_terms.md`というファイルが変更済(modified)で，かつステージング済の状態なので，このファイルはコミット対象になります。  

このファイルをコミットすると，
```zsh
$ git commit -m "[Modify] 02_git_terms.md"

[master 75cb318] [Modify] 02_git_terms.md
 1 file changed, 116 insertions(+), 11 deletions(-)
```
と出てきて，無事コミットできました！これで変更が保存されるわけですね〜。

</details>

</br>

## git rm

みなさんご存知の通り，普通ファイルを消したい時は，`rm {ファイルのパス}`でファイルを消すことができます。しかし，Gitの管理下にあるディレクトリでこれを行うとほんのちょっと面倒くさいことになります。  

「ファイルをGitから消す」，ということは， 「**追跡対象から外し（ステージングエリアからの削除），コミットする**」 までの一連の作業をしなければなりません。が，普通の`rm`のみだと，ステージされてない状態になってしまいます。  

そこで登場するのが，`git rm`です（gitつけただけじゃねーか！！）。`rm`の代わりに`git rm`でファイルを削除すれば，ファイルを追跡対象から外し，ディレクトリからファイルを削除できます。完全消去です。  

変更済のファイルを既にステージしている場合はオプション`-f`をつけて強制的に削除しましょう。  

</br>

<details><summary>具体例（折りたたみ）</summary>

</br>

### EX 

例えば，間違って`03_hoge.md`というファイルを作成してしまったとしましょう。これを`git add 03_hoge.md`でステージしちゃいましょう。すると，  

```zsh
$ git status

On branch master
Your branch is up to date with 'origin/master'.

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        new file:   03_hoge.md
```
となりますね。  

これを`rm 03_hoge.md`で削除すると，
```zsh
$ rm 03_hoge.md
$ git status

On branch master
Your branch is up to date with 'origin/master'.

Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        deleted:    03_hoge.md
```
となって，`Changes not staged for commit`という， **ステージされていない** 欄に表示されます。  

これでは削除したことがコミットできず，追跡を外せないので，`git rm`を使いましょう。  
```zsh
$ git rm 03_hoge.md

rm 'documents/git/03_hoge.md'

$ git status

On branch master
Your branch is up to date with 'origin/master'.

nothing to commit, working tree clean
```
となって，綺麗さっぱりですね〜。

</details>

</br>

<details><summary>他にも...（折りたたみ）（正直読まなくていい）</summary>

</br>

読まなくていいとか書かれると読みたくなるよね〜。  

本当に読まなくてもいいので，ざっくり書きます。  

「ファイル自体はワーキングツリーに残しつつ，ステージングエリアからの削除」がオプション指定でできます。主に，手元には残しておきたいけど追跡はしなくていいやという場合でしょうか。その場合は，
```zsh
$ git rm --cached {ファイル名}
```
でできます。ログファイルがステージされたときとか，`.a`とか`.out`が大量にステージされてしまった時などに便利。  

また，glob パターンを`git rm`に渡すこともできます。例えば，  
```zsh
$ git rm log/\*.log
```
などのようにすれば，`log/`ディレクトリの中の，拡張子`.log`のファイルを全て削除します。このとき，シェルによる`*`の解釈を避けるため，バックスラッシュ`\`を用いてエスケープします。(※3)  

また，同じように書き方の例として，  
```zsh
$ git rm \*~
```
とすれば，`~`で終わる全てのファイルを削除できます。ここらへんの書き方は難しいですね。正直pythonを使うなら使うことはほぼほぼないとは思いますが，C/C++などを使うなら，`.gitignore`を作り忘れて（また，作っていたけれど拡張子を含め忘れて）実行ファイルが大量にステージングされてしまった場合など，使うはめになりそうですね。。。 

</br>

<details><summary>※3（折りたたみ）（長すぎ注意）</summary>

</br>

ここはもっと読まなくていい場所ですが，来てくれてありがとう。  

そもそも **「グロブ(glob)」** というのは， **「ワイルドカードを用いてファイル名を指定するパターン」** のことです。  

そして **「ワイルドカード」** というのは， **「どんな対象や文字列にもマッチする文字」** のことです。  

例えばポーカーや大富豪をやっているとき，たまにジョーカーを入れて遊びますよね。このジョーカーはいわゆる「ワイルドカード」として扱われています。ポーカーをしているときに，手札にJが2枚とジョーカーが1枚あったら，ジョーカーをJ扱いして，役はスリーカードとなりますよね。大富豪なら，手札に5が3枚あって，ジョーカーが1枚あれば，これらを全部出して革命を起こすこともできます。つまりは，何にでもなれる，"僕の考えた最強のカード"，がワイルドカードです。　　

Unix系で用いられる「ワイルドカード」もこれとほぼ同じような意味で使われます。よく使う例として，以下の2つがあります。（他にも[]などがあります）  

| ワイルドカード | 意味 |
| :---: | ---- |
| * | 	0文字以上の任意の文字列にマッチ |
| ? | 任意の1文字にマッチ |  

なので，例えば，`*.txt`というグロブを考えたとき，これは`abc.txt`とか`aiueo.txt`とか`hatty.txt`とか，全ての`.txt`で終わるファイルにマッチします。他にも，`?`を使った,
`???.xlsx`というグロブを考えれば，`aiu.xlsx`にはマッチしますが，`abcde.xlsx`にはマッチしません，といった具合です。`?`は一文字分ですからね。ちなみに`*.*`とすれば全ファイルを指せます。    

なので，さっき例に示した，こちら
```zsh
$ git rm log/\*.log
```
というのは，logディレクトリ以下の（`log/`），`.log`と名のつくファイルを全て削除，というコマンドになることが読み取れると思います。  

さてここからが本題なのですが，上の例で見たように，なぜか`*`がバックスラッシュ`\`でエスケープされて（エスケープ処理：簡単にいうと，特殊な文字をただ単に普通の文字列として扱うこと。つまり特殊な効果が発揮されなくなる()）います。この理由についてグチグチ述べようと思います。  

これを行う理由は，さっきもちらっと書いていますが，  **「Gitがファイル名の展開を自前で行うので，シェルによるファイル名の展開を防ぐため」** です。これでわかった天才さんは帰ってもらって大丈夫です。  

これの説明はなかなかにめんどくさいのですが（どうせ読んでる人いないだろうし）頑張ります。  

例えば，みなさんご存知の通りカレントディレクトリ（今いるディレクトリ）の中で，どんなファイルがあるのかを調べるのには，`ls`コマンドを使いますよね。`ls`コマンドにファイル名を渡せば，そのファイルがあるかどうか調べてくれます。なので，ワイルドカードを用いれば，「〇〇と名のつくファイルがあるかどうか」を調べてくれることになりますよね。だから，カレントディレクトリにおいて，  
```zsh
$ ls

abc_1.py abc_2.cpp abc_3.rs def_1.out
```
のようになっているとしましょう。このとき，
```zsh
$ ls abc*

abc_1.py abc_2.cpp abc_3.rs
```
と返されることになります。これが便利な検索のかけ方ですね。このとき何が起こっているかというと，
```zsh
$ ls abc*
```
と打つと，これは
```zsh
$ ls abc_1.py abc_2.cpp abc_3.rs
```
のように **ワイルドカード付き文字列 "abc\*" が、この表現に合致するカレントディレクトリ内のファイルに変換され** ます。そして，この作業のことを **「展開」** と呼ぶわけです。（~~展開展開って，cansat運営か？~~）  

これは非常に便利な機能なんですが，もしこの「展開」機構（cansat?）を他のアプリやコマンドが持っていたらどうでしょうか？  

例えば，`grep`を考えましょう。`grep`の使い方は省きますが，多分見れば分かります。`ls abc*`と同じような使い方ですね。
```zsh
$ ls | grep abc_1.py

abc_1.py
```
のような使い方です。では今度はこんな検索を考えてみましょう。
```zsh
$ ls | grep abc*


```
さっきの`ls abc*`のように`abc`と名のつくファイルが出てきてもいいような気がしますが，実は何も出てきません。これが現実です。  

これが出てこない理由は，「展開」にあります。さっきも言ったように，`*`を見るとシェル（シェルについての説明は脱線しすぎなのでしません）は展開し始めます。なので，
```zsh
$ ls | grep abc*
```
は
```zsh
$ ls | grep abc_1.py abc_2.cpp abc_3.rs
```
と同義なわけです。しかし`grep`は第一引数に検索文字列，第二引数以降は検索対象ファイルとりますから，`abc_1.py`というファイルを，`abc_2.cpp`と`abc_3.rs`の中から必死に探しているわけです。なので何も返ってきません。  

少し話はそれますが，ワイルドカードというものはどこかしこで使える訳ではありません。Linux や Unix においてはワイルドカードは主にbash等のシェルで使われますが，広く一般にコマンド，アプリケーションで用いられている訳ではなく，コマンド，アプリケーションにおいては，ワイルドカードの置換として，「正規表現」というものが使われていることが多いです。正規表現の一例として，ワイルドカードでいう`*`は`.*`として表されます。  

基本的にはシェルが展開してコマンド（ないしはアプリケーション）に渡すのが一般的ですが，稀なケースとしてコマンド自身がワイルドカードを解釈して使う場合があります（`grep`もそうですし，`find`やそれこそ`git`がこれにあたります）。  

`grep`はワイルドカードを解釈できませんが，正規表現は解ります。そこで正規表現を用いて書いてみると，
```bash
$ ls | grep abc.*

abc_1.py abc_2.cpp abc_3.rs
```
と出てきます。これは **シェルが，`abc.`と名のつくファイルをカレントディレクトリから探して，存在しなかったために`abc.*`を展開せず，`grep`にそのまま渡し** ，`grep`はこの正規表現を理解して探したからです。（補足として，基本 Linux や Windows のシェルは正規表現を理解できません）  

それでは本題の`git rm`について見ましょう。  
```zsh
$ git rm log/\*.log
```
では，`*`をエスケープすることで（`\*`） シェルはこれを普通の文字`*`として扱い，展開を行い **ません** 。これをすることで **確実に`git rm`にワイルドカードとして渡せる** 訳です。  

では，展開してしまったら何がまずいのでしょう？これはディレクトリ構造に依存するので，一概に展開するのが間違い，展開しない方が良い，というわけではないと僕は思います。  

例えば，このようなディレクトリ構造を考えてみましょう。
```zsh
log 
├── 01.log
├── 02.log 
└── other_data 
    └── 03.log
```
このとき，`.log`と名のつくファイルを全消去したいとしましょう（01~03全部です）。ここでもし，
```zsh
$ git rm log/*.log
```
と打つと，まずはシェルによる展開が入るので，`*.log`は`log`ディレクトリにあるファイルのうち，条件に合致するものに置き変わることになります。それが「展開」の意味でした。なのでこの場合，
```zsh
01.log 02.log other_data
```
を見るので，`*.log`は`01.log 02.log`に置き換わることになります。要するに結局やっていることは，
```zsh
$ git rm 01.log 02.log
```
と同じな訳です。これでは`03.log`が削除されていません。これを確実に削除するためには，`git rm`にワイルドカードを渡さなければなりません。そのために，シェルに解釈されないようにエスケープ処理を挟む，ということになります。長い道のりでした。  

つまり，
```zsh
$ git rm log/\*.log
```
とすれば，  

1. シェルは`\*`をただの文字列`*`として解釈するので，`git rm`には引数として`log/*.log`が渡される。  
2. Gitは自前で展開が行えるので，ワイルドカード`*`を解釈して，`log/`以下にある`.log`ファイルを全削除。

という流れになるわけです。疲れたー。  

</br>

<details><summary>ちょっとだけ大切なお話（折りたたみ）</summary>

</br>

今まで「シェル」とかいてきましたが，これは主に bash の話だと思ってください。zsh ではワイルドカードの展開に対する動作がやや異なるようです。詳しくは調べてください。そして他のシェルを使っているなら調べてください。（ぶん投げ）

</details>

</br>

<details><summary>本当にどうでもいい話（折りたたみ）</summary>

</br>

`*`はグロブスターと言ったりするらしいです。  

そこでややオカルト好きな僕はUMA（未確認生命体）の「グロブスター」を連想しましたが（やや閲覧注意です），こっちのグロブスターは「グロテスク・ブロブ・モンスター」の略のようで，何も関係ありませんでした。絶対これだと思ったんだけどなーーー。  


</details>

</details>

</details>

</br>

## git mv

Gitは他のVCSと異なり，ファイルの移動を明示的に追跡するということはしないそうです。でも，ファイル名を変更したらGitはファイル名が変更ことがわかるらしいです。賢いですね。  

にもかかわらずGitには`mv`コマンドが存在します。これは`rm`と似ていますが，本来ファイル名を変更したり，ファイルを移動させたりしたときにやるべき作業を一緒にやってくれる，ということだけです。  

使い方は普通の`mv`コマンドと全く同じです。ファイル名の変更であれば，  
```zsh
$ git mv {今のファイル名} {変更したいファイル名}
```
ファイルの移動であれば，
```zsh
$ git mv {移動させるファイル名} {移動先のディレクトリ名}
```
です。本当におんなじですね。

</br>

<details><summary>具体例（折りたたみ）</summary>

</br>

### EX

これもいらないとは思いますが，載っけておきます。  

いつも通り，`03_hoge.md`というファイルを作っておきます。これを`03_fuga.md`というファイルに名前を変えたいとします。  

`git mv`コマンドを使用してファイル名を変更すると，こんな感じになります。
```zsh
$ git mv 03_hoge.md 03_fuga.md
$ git status

On branch master
Your branch is up to date with 'origin/main'.

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	renamed:    03_hoge.md -> 03_fuga.md
```
となって，無事ステージされます。これは結局，
```zsh
$ mv 03_hoge.md 03_fuga.md
$ git rm 03_hoge.md
$ git add 03_fuga.md
```
とやっていることは一緒です。コマンドを何回叩くかということだけの違いですね。

</details>

</br>

## git log

これについては書こうと思うと多すぎて書ききれないので，要点だけ見ていきます。  

`git log`はコミットの履歴を返します。コミットにはSHA-1のハッシュ番号がついており，`git log`をしたときに出てくるうじゃうじゃした40桁のチェックサムはコミットの名前とか識別番号だと思ってください。（56e8681816dbe3ba0de16d744698e3ec985180d7 ← こんな感じのやつ）  

使い方は
```zsh
$ git log
```
で良いです。シンプルですね。何も引数を指定しなければ，そのリポジトリでの直近のコミットがエディタで開かれて返ってきます。このコマンドは， SHA-1チェックサム，作者の名前とメールアドレス，コミット日時，コミットメッセージを一覧表示します。ぜひ遊んでみてください。  

</br>

<details><summary>出力例（折りたたみ）</summary>

</br>

```zsh
$ git log

commit f7264cdb57ec3380930d93f4373bbc9921c728ad (HEAD -> master, origin/master)
Author: laika90 <作者のメアド>
Date:   Sun Oct 9 14:19:20 2022 +0900

    [Modify] 02_git_terms.md

commit 2e13f23b4ec02311221a1e242381485eb91dc1b4
Author: laika90 <作者のメアド>
Date:   Sun Oct 9 12:34:27 2022 +0900

    [Modify] 02_git_terms.md

commit 56e8681816dbe3ba0de16d744698e3ec985180d7
Author: laika90 <作者のメアド>
Date:   Sun Oct 9 12:33:15 2022 +0900
```

```zsh
$ git log --pretty=oneline

f7264cdb57ec3380930d93f4373bbc9921c728ad (HEAD -> master, origin/master) [Modify] 02_git_terms.md
2e13f23b4ec02311221a1e242381485eb91dc1b4 [Modify] 02_git_terms.md
56e8681816dbe3ba0de16d744698e3ec985180d7 [Modify] 02_git_terms.md
4ce1ea44041918e09b0b8a250e8a946776a159e5 [Modify] 02_git_terms.md
5dd507399f4f6d8e1c388f0eb0fdff65bf354551 [Modify] 02_git_terms.md
44910bf0f6dff8838fb8c7e06bbaa270ffb54167 [Modify] 02_git_terms.md
c3759f99b662f2a298c93d91b5ddbb47022cf56f [Modify] 02_git_terms.md
5ee71fa996ee21bbb0b581209b2b8127e5ba4843 [Modify] 02_git_terms.md
75cb318200179e8a42341282ab1b881b96866dfb [Modify] 02_git_terms.md
d117ab3115b650a8980b4c60544a0223fea84bd1 [Modify] 02_git_terms.md
efb81abcbaed9c8bbabb45ec24bf37b3840291da [Modify] 02_git_terms.md
cff9d5c320fe00e3ed860b45549feecf0611d5bd [Modify] 02_git_terms.md
092761b621e24cda1be0b1b8c0fde6bf8144cce9 [Modify] 02_git_terms.md
14165a7e8b0b1bcf1638e2c296c879c7ed98b005 [Add] 02_07
0d1b54f14421d07f5752dcdfa9270b4376f7e06a [Add] .gitignore
```

```zsh
$ git -SGit

commit f7264cdb57ec3380930d93f4373bbc9921c728ad (HEAD -> master, origin/master)
Author: laika90 <作者のメアド>
Date:   Sun Oct 9 14:19:20 2022 +0900

    [Modify] 02_git_terms.md

commit 5dd507399f4f6d8e1c388f0eb0fdff65bf354551
Author: laika90 <作者のメアド>
Date:   Sun Oct 9 12:25:04 2022 +0900

    [Modify] 02_git_terms.md

commit c3759f99b662f2a298c93d91b5ddbb47022cf56f
Author: laika90 <作者のメアド>
Date:   Sun Oct 9 00:35:07 2022 +0900
```

何となくメールアドレスは隠させてもらいました。いや，別にバレても良いんだけどね？

</details>

</br>

<details><summary>便利なオプションず（折りたたみ）</summary>

</br>

ログを見る以上，本当に見たい情報が見れないと意味ないですよね。そこでオプションをつけてより見やすくするのが良いでしょう。以下は`git log`のオプションです。  

| オプション | 意味 |
| ---- | ---- |
| `-p` | 各コミットのパッチを表示する |
| `--stat` | 各コミットで変更されたファイルの統計情報を表示する |
| `--shortstat` | --stat コマンドのうち、変更/追加/削除 の行だけを表示する |
| `--name-only` | コミット情報の後に変更されたファイルの一覧を表示する |
| `--name-status` | 変更されたファイルと 追加/修正/削除 情報を表示する |
| `--abbrev-commit` | SHA-1 チェックサムの全体 (40文字) ではなく最初の数文字のみを表示する |
| `--relative-date` | 完全な日付フォーマットではなく、相対フォーマット (“2 weeks ago” など) で日付を表示する |
| `--graph` | ブランチやマージの歴史を、ログ出力とともにアスキーグラフで表示する |
| `--pretty` | コミットを別のフォーマットで表示する。オプションとして oneline, short, full, fuller そして format (独自フォーマットを設定する) を指定可能 |

（補足）  

`--pretty`に関しては，
```zsh
$ git log --pretty=oneline
```
のように使用する。

</details>

</br>

<details><summary>制限（折りたたみ）</summary>

</br>

`git log`の出力には制限をかけることができます。これで必要としているところだけ抜き出せるんですね。

| オプション | 意味 |
| ---- | ---- |
| `-n` | 直近の n 件のコミットのみを表示する（nは任意の自然数を入れてください） |
| `--since`, `--after` | 指定した日付より後に作成されたコミットのみに制限する |
| `--until`, `--before` | 指定した日付より前に作成されたコミットのみに制限する |
| `--author` | エントリが指定した文字列にマッチするコミットのみを表示する |
| `--committer` | エントリが指定した文字列にマッチするコミットのみを表示する |
| `--grep` | 指定した文字列がコミットメッセージに含まれているコミットのみを表示する |
| `-S` | 指定した文字列をコードに追加・削除したコミットのみを表示する |  

（補足）  

書き方の例  
```zsh
$ git log --since=2.weeks
$ git log --since=2020-10-08
$ git log --since="2020-10-08"
$ git log --since="1 years 2 day 3 minutes ago"
$ git log -Sfunction_name
```
</details>

</br>

## ブランチ(Branch)

Gitのブランチ機能は他のVCSと比較してかなり優れていて，Gitの一番素晴らしい機能という人もいるらしいです。  

ブランチとはその名の通り，「枝」を意味します。開発が時の流れに沿って。幹があって枝があってというような木とか川の流れになっていると想像してみてください。  

例えば，ゲームの開発を行なっているとしましょう。ゲームの開発ではバグの方向は日常茶飯事ですし（知らんけど），ユーザーを飽きさせないために，新しい機能やイベントと言ったゲームのバージョンアップを行わないといけません。急なバグの修正を行わなければならなくなったとき，新たなイベントや機能を追加したいとき，もしVCSを使わずに，ゲームを作っていたらどうでしょう。バグの修正が終わるまで，または新機能やイベントの開発が終わるまで，ユーザーはゲームを遊べなくなってしまいますよね？これではやっとこさベントを開催しても遊んでくれる人なんで誰一人いません。悲しくなります。  

そこで，バージョン管理やバグ修正をするには，開発の本流ととバージョンアップデート開発の分流，バグ修正の分流，というように，開発範囲ごとに環境を分けられたらなぁ，と考えます，そうすれば，開発者は時間を気にせず，修正したコードを容易にテストすることができますし，ユーザーは今のままの状態で継続して遊べるのでWin-Winになります（開発の本流には手を加えてないので，ユーザーはそのまま遊べます）。そしてバグやバージョンアップデートの開発が終わったら，それを本流に加えることができたらアップデートも一瞬で終わり，ミスも少なくなりますね。その本流と分流を分ける機能こそが **「ブランチ」** であり。本流から分流を作る作業を **「ブランチを切る」** と言います。  

Gitのブランチ機能の強みはその早さ故のブランチの切りやすさにあります。他のVCSにもブランチの機能自体はありますが，本流のコピーを丸々作るため，ブランチを作るのにとても時間がかかり重いですが，Gitはその性質上，ブランチ作るのが非常に早く軽いです。そのため，VCSとしてGitを用いる最大のメリットはブランチ機能によるバージョン管理にあるのでしょう。（なぜ軽いのかは後述します。必ずしも覚える必要はありませんが，理解しておくとその後の理解がスムースになると思います。）  








[prev](https://github.com/laika90/b2multicopter/blob/document/documents/git/01_about_git.md) | [next](https://github.com/laika90/b2multicopter/blob/document/documents/git/03_quick_reference.md)

















 



